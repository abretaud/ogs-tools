#!/usr/bin/env python

# Check that an OGS GFF file is ready for release

import argparse
import logging
import sys

from BCBio import GFF

from Bio.SeqFeature import FeatureLocation, SeqFeature


logging.basicConfig(level=logging.INFO)
log = logging.getLogger()


def change_parentname(feature, parentKeyName, parentName):

    for child in feature.sub_features:
        child.qualifiers[parentKeyName][0] = parentName

    return


class OgsCheck():

    def __init__(self):
        self.mRNA_ids = []
        self.exon_ids = []
        self.skipped_types = set()
        self.qlistName = ['Name', 'ID']

    def check_valid_mrna(self, mrna):

        if mrna.type == 'transcript':
            mrna.type = "mRNA"

        if mrna.type != 'mRNA':
            self.skipped_types.add(mrna.type)
            return None

        if 'ID' not in mrna.qualifiers or len(mrna.qualifiers['ID']) == 0:
            log.error("Found an mRNA without an ID attribute")
            return None

        if len(mrna.qualifiers['ID']) != 1:
            log.error("Found an mRNA with too many ID attributes")
            return None

        if mrna.qualifiers['ID'][0] in self.mRNA_ids:
            log.error("Duplicate mRNA id: %s" % mrna.qualifiers['ID'][0])
            return None

        self.mRNA_ids.append(mrna.qualifiers['ID'][0])

        exon_coords = {}
        cds_cumul = 0

        # Find positions
        kept_gchild = []
        self.exon_ids = []

        for gchild in mrna.sub_features:  # exons, cds, utr
            if gchild.type == "exon":
                exon_coords[gchild.location.start] = gchild.location.end
            elif gchild.type == "CDS":
                cds_cumul += gchild.location.end - gchild.location.start - 1

            if gchild.type in ['five_prime_utr', "5'UTR"]:
                gchild.type = 'five_prime_UTR'

            if gchild.type in ['three_prime_utr', "3'UTR"]:
                gchild.type = 'three_prime_UTR'

            if gchild.type in ['exon', 'CDS', 'five_prime_UTR', 'three_prime_UTR']:
                kept_gchild.append(gchild)
            else:
                self.skipped_types.add(gchild.type)

            if gchild.type == "exon":
                if 'ID' not in gchild.qualifiers or len(gchild.qualifiers['ID']) == 0:
                    log.error("Found an exon without an ID attribute")
                    return None

                if len(gchild.qualifiers['ID']) != 1:
                    log.error("Found an exon with too many ID attributes")
                    return None

                if gchild.qualifiers['ID'][0] in self.exon_ids:
                    log.error("Duplicate exon id: %s" % mrna.qualifiers['ID'][0])
                    return None

                self.exon_ids.append(gchild.qualifiers['ID'][0])

        mrna.sub_features = kept_gchild

        # Check minimum intron size
        start_sorted = sorted(exon_coords)
        previous_end = None
        for exon_start in start_sorted:
            if previous_end is not None:
                intron_size = exon_start - previous_end
                if intron_size < 9:
                    log.warning("Discarding '%s' because intron size %s < 9" % (mrna.qualifiers['ID'][0], intron_size))
                    return None

            previous_end = exon_coords[exon_start]

        # Check minimum cds size
        if cds_cumul < 15:
            log.warning("Discarding '%s' because CDS size < 15 (%s)" % (mrna.qualifiers['ID'][0], cds_cumul))
            return None

        return mrna

    def find_inferred_parents(self, features):
        inferred = {}
        for topfeat in features:
            if topfeat.type == 'inferred_parent':
                inferred[topfeat.qualifiers['ID'][0]] = topfeat

        return inferred

    def check(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
        parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
        args = parser.parse_args()

        scaffs = []
        for scaff in GFF.parse(args.infile):
            scaff.annotations = {}
            scaff.seq = ""
            new_genes = {}

            # First check if we have inferred_parent (generated by bcbio-gff)
            inferred_parents = self.find_inferred_parents(scaff.features)

            for topfeat in scaff.features:

                if topfeat.type not in ['gene', 'mRNA']:
                    if topfeat.type != 'inferred_parent':
                        self.skipped_types.add(topfeat.type)
                    continue

                if 'ID' not in topfeat.qualifiers or len(topfeat.qualifiers['ID']) == 0:
                    log.error("Found a gene without an ID attribute")
                    continue

                if len(topfeat.qualifiers['ID']) != 1:
                    log.error("Found a gene with too many ID attributes")
                    continue

                if topfeat.qualifiers['ID'][0] in new_genes.keys():
                    log.error("Duplicate gene id: %s" % topfeat.qualifiers['ID'][0])
                    continue

                if topfeat.type == 'gene':
                    # Simple case: a gene with mub features
                    new_mrnas = []

                    for mrna in topfeat.sub_features:

                        mrna = self.check_valid_mrna(mrna)

                        if mrna is not None:
                            new_mrnas.append(mrna)

                    topfeat.sub_features = new_mrnas
                    new_genes[topfeat.qualifiers['ID'][0]] = topfeat

                elif topfeat.type == 'mRNA':
                    # Found an mRNA without gene parent
                    # Validate it, create a gene parent, and look if we have a corresponding inferred_parent containing children from this mRNA
                    if 'Parent' in topfeat.qualifiers and len(topfeat.qualifiers['Parent']) == 1:
                        parent_id = topfeat.qualifiers['Parent'][0]
                        mrna_id_needs_change = False
                    else:
                        parent_id = topfeat.qualifiers['ID'][0]
                        mrna_id_needs_change = True

                    if 'ID' in topfeat.qualifiers and len(topfeat.qualifiers['ID']) == 1:
                        if len(topfeat.sub_features) == 0 and topfeat.qualifiers['ID'][0] in inferred_parents:
                            topfeat.sub_features = inferred_parents[topfeat.qualifiers['ID'][0]].sub_features

                    topfeat = self.check_valid_mrna(topfeat)

                    if topfeat is None:
                        continue

                    if topfeat is not None:

                        if parent_id in new_genes:
                            new_genes[parent_id].sub_features.append(topfeat)
                        else:
                            q = {}
                            for key in topfeat.qualifiers:
                                q[key] = list(topfeat.qualifiers[key])
                            new_g = SeqFeature(FeatureLocation(topfeat.location.start, topfeat.location.end), type="gene", strand=topfeat.location.strand, qualifiers=q)
                            for qn in self.qlistName:
                                if qn in new_g.qualifiers:
                                    new_g.qualifiers[qn][0] = parent_id
                            if mrna_id_needs_change:
                                for qn in self.qlistName:
                                    if qn in topfeat.qualifiers:
                                        # The new gene is assigned the id from the mrna, and the mrna gets a suffix
                                        topfeat.qualifiers[qn][0] = parent_id + '-R'
                            new_g.sub_features = []
                            new_g.sub_features.append(topfeat)
                            topfeat.qualifiers['Parent'] = new_g.qualifiers['ID']
                            if 'Parent' in new_g.qualifiers:
                                del new_g.qualifiers['Parent']
                            change_parentname(topfeat, 'Parent', topfeat.qualifiers['ID'][0])
                            new_genes[parent_id] = new_g

            scaff.features = new_genes.values()

            if len(new_genes):
                scaffs.append(scaff)

        GFF.write(scaffs, args.outfile)

        if self.skipped_types:
            log.warning("Skipped unknown/misplaced feature types: %s" % (self.skipped_types))


if __name__ == '__main__':
    ogsc = OgsCheck()

    ogsc.check()
